

# Notes: Structured Analysis & SDLC

### Structured Analysis

* A **traditional system development technique**: time-tested, easy to understand.
* Uses the **System Development Life Cycle (SDLC)** to **plan, analyze, design, implement, and support** an information system.
* Considered a **predictive approach**: follows an overall plan (like a **building blueprint**).
* Focus: **processes** that transform data into useful information → a **process-centered technique**.
* Uses **process models** (e.g., **Data Flow Diagrams, DFDs**) to represent how **data enters, is transformed, and exits**.
* Covers **data organization, relational database design, and user interface issues**.

---

### SDLC Phases (Waterfall Style)

**1. Systems Planning**

* Starts with a **systems request** (formal request to IT).
* Request can be **major** (new system) or **minor** (UI change).
* Preliminary investigation → **feasibility study** (reviews **costs, benefits, operational, technical, economic, and time** factors).
* Sometimes solution is not IT but **business process changes** (training, workflow).

**Q: What kind of requirements are described and what do they generate? Are requests auto-generated?**
➡ They come from **business goals or problems** (e.g., faster reporting, compliance). These generate **system requests**. They are **human-initiated**, not auto-generated.

**Q: What is an example of a feasibility study?**
➡ Example: A company considers a **new payroll system**. Costs = \$200k software, \$50k training. Benefits = fewer errors, faster processing, compliance. Technical = **compatibility with HR software**. Time = can it be done before **tax season**?

**Q: What does it mean that a business process review may be recommended instead of an IT solution?**
➡ Sometimes the **problem is the workflow, not the system**. For example, reports might be late because staff need **training** or steps need to be reorganized.

---

**2. Systems Analysis**

* Goal: build a **logical model** of the new system.
* **Requirements modeling**: interviews, surveys, observations, document reviews, sampling.
* Output: **System Requirements Document**.

**Q: What requirements are recorded in the System Requirements Document? How is this different from a feasibility study?**
➡ It records **functional requirements** (what the system must do) and **non-functional requirements** (performance, security, usability).
➡ A **feasibility study** asks: *“is the project worth it?”* The **requirements document** asks: *“what exactly must the system do?”*

---

**3. Systems Design**

* Purpose: create a **physical model** of the system.
* Design **user interface, inputs, outputs, processes**.
* Add **internal/external controls** (accuracy, security, reliability, maintainability).
* Decide **application architecture** (the blueprint for how programs, databases, and modules will run).
* Deliverable: **System Design Specification**.

**Q: Are outputs, inputs, and processes like declared variables? What is application architecture?**
➡ Yes, they are similar: they define **what data goes in, what comes out, and how it is processed**.
➡ **Application architecture** = the **overall structure**: what **programs, modules, and tech stack** will run the system.

---

**4. System Implementation**

* Developers **write, test, document, and install** the system.
* If purchased software, it is **configured and customized**.
* Deliverable: a **fully functioning, documented system**.
* Final prep: **data conversion, user training, deployment**.
* Ends with **systems evaluation** (does it meet goals and expectations?).

**Q: From a programmer’s perspective, what is expected here?**
➡ Programmers must **code, test, and document** modules. Documentation includes **technical specs, code comments, user guides, and system manuals**. This goes **beyond a README**—it ensures others can maintain and enhance the system.

---

**5. Systems Operations**

* System is delivered to users, then **maintained and enhanced**.
* **Maintenance** → fix errors, adapt to changes (e.g., new tax laws).
* **Enhancements** → add features.
* Focus: maximize **return on investment**, **security**, and **scalability**.
* Systems often need **upgrades or replacements** after a few years.

---

### Core Clarifications

**Q: What does it mean that the SDLC describes activities performed regardless of approach?**
➡ Whether using **structured, object-oriented, or agile methods**, developers always **plan, analyze, design, implement, and support**. The steps are **universal**.

**Q: Why is the waterfall model criticized for lack of interactivity between phases?**
➡ Because in a **strict waterfall**, you finish one phase before the next. Real life requires **feedback loops** (e.g., revisiting requirements when design reveals gaps). Lack of this back-and-forth is a **disadvantage**.

---

Do you also want me to **map each SDLC phase to your role as a programmer** (like: in Planning you help gather info, in Design you prep specs, in Implementation you code), so it’s clear what your job would look like in practice?
